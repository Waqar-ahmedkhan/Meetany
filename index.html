<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTC Video Call</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f0f0f0;
      }
      #videoContainer {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
      }
      video {
        width: 45%;
        border: 1px solid #ccc;
        background-color: #000;
        border-radius: 8px;
      }
      #controls,
      #messageContainer {
        margin-top: 20px;
      }
      button {
        padding: 10px 20px;
        margin: 5px;
        cursor: pointer;
        border: none;
        border-radius: 4px;
        background-color: #4caf50;
        color: white;
        font-weight: bold;
      }
      button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }
      #messageInput {
        width: 70%;
        padding: 10px;
        border-radius: 4px;
        border: 1px solid #ccc;
      }
      #messages {
        border: 1px solid #ccc;
        padding: 10px;
        height: 200px;
        overflow-y: scroll;
        background-color: #fff;
        border-radius: 4px;
        margin-top: 10px;
      }
      .user-info {
        background-color: #fff;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .status {
        padding: 8px;
        margin: 5px 0;
        border-radius: 4px;
        background-color: #e9e9e9;
      }
      .error {
        color: #d32f2f;
        background-color: #ffebee;
      }
      .success {
        color: #388e3c;
        background-color: #e8f5e9;
      }
    </style>
  </head>
  <body>
    <h1>WebRTC Video Call</h1>

    <div class="user-info">
      <h3>User Information</h3>
      <div>
        <label
          >User ID:
          <input
            id="userId"
            type="text"
            placeholder="Enter your unique ID"
            required
        /></label>
      </div>
      <div>
        <label
          >Name:
          <input
            id="userName"
            type="text"
            placeholder="Enter your name"
            required
        /></label>
      </div>
      <div>
        <label
          >Gender:
          <select id="userGender">
            <option value="male">Male</option>
            <option value="female">Female</option>
            <option value="both">Both</option>
          </select>
        </label>
      </div>
      <button onclick="connectUser()">Connect</button>
      <div id="connectionStatus" class="status">Not connected</div>
    </div>

    <div id="videoContainer">
      <div>
        <h3>You</h3>
        <video id="localVideo" autoplay muted></video>
      </div>
      <div>
        <h3>Remote</h3>
        <video id="remoteVideo" autoplay></video>
      </div>
    </div>

    <div id="callControls" class="user-info">
      <h3>Call Controls</h3>
      <button onclick="startCall()" disabled id="startCallBtn">
        Start Call
      </button>
      <button onclick="endCall()" disabled id="endCallBtn">End Call</button>
      <div id="callStatus" class="status">No active call</div>
    </div>

    <div id="messageContainer" class="user-info">
      <h3>Chat</h3>
      <div>
        <input
          id="messageInput"
          type="text"
          placeholder="Type a message..."
          disabled
        />
        <button onclick="sendMessage()" disabled id="sendMessageBtn">
          Send
        </button>
      </div>
      <div id="messages"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <script>
      // DOM Elements
      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");
      const startCallBtn = document.getElementById("startCallBtn");
      const endCallBtn = document.getElementById("endCallBtn");
      const sendMessageBtn = document.getElementById("sendMessageBtn");
      const messagesDiv = document.getElementById("messages");
      const messageInput = document.getElementById("messageInput");
      const connectionStatus = document.getElementById("connectionStatus");
      const callStatus = document.getElementById("callStatus");

      // WebRTC Configuration
      const configuration = {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" },
          { urls: "stun:stun2.l.google.com:19302" },
        ],
      };

      // Application State
      const state = {
        socket: null,
        localStream: null,
        peerConnection: null,
        currentCallId: null,
        user: {
          id: "",
          name: "",
          gender: "male",
          connected: false,
        },
        remoteUser: {
          id: "",
          name: "",
          gender: "",
        },
        iceCandidates: [],
      };

      // Initialize Socket.IO connection
      function initializeSocket() {
        state.socket = io("http://localhost:3000", {
          reconnectionAttempts: 5,
          reconnectionDelay: 1000,
          autoConnect: false,
        });

        // Socket event handlers
        state.socket.on("connect", () => {
          updateStatus("Connected to signaling server", "success");
        });

        state.socket.on("disconnect", () => {
          updateStatus("Disconnected from signaling server", "error");
          resetConnection();
        });

        state.socket.on("connect_error", (err) => {
          updateStatus(`Connection error: ${err.message}`, "error");
        });

        state.socket.on("message", handleSocketMessage);
      }

      // Handle incoming socket messages
      async function handleSocketMessage(message) {
        try {
          const data =
            typeof message === "string" ? JSON.parse(message) : message;
          logMessage("Received:", data);

          switch (data.type) {
            case "user_already_exists":
              showError("User already exists with this ID");
              resetConnection();
              break;

            case "call_connected":
              handleCallConnected(data);
              break;

            case "call_response":
              updateStatus(data.data, "success");
              break;

            case "offer_received":
              await handleOfferReceived(data);
              break;

            case "answer_received":
              await handleAnswerReceived(data);
              break;

            case "ice_candidate":
              await handleIceCandidate(data);
              break;

            case "call_ended":
              handleCallEnded(data);
              break;

            case "message_received":
            case "message_sent":
              displayMessage(data);
              break;

            case "error":
              showError(data.message);
              break;

            default:
              logMessage("Unknown message type:", data.type);
          }
        } catch (error) {
          console.error("Error handling message:", error);
          showError("Error processing message");
        }
      }

      // Handle call connected event
      function handleCallConnected(data) {
        if (data.data === "No available user for the call") {
          updateStatus("No available users for call", "error");
          return;
        }

        state.remoteUser = {
          id: data.data,
          name: data.name,
          gender: data.gender,
        };

        updateStatus(`Connected to ${data.name} (${data.gender})`, "success");
        startCallBtn.disabled = false;
        messageInput.disabled = false;
        sendMessageBtn.disabled = false;
      }

      // Handle offer received
      async function handleOfferReceived(data) {
        try {
          if (!state.peerConnection) {
            createPeerConnection();
            logMessage("Created new peer connection for offer");
          }

          if (!data.data || typeof data.data !== "string") {
            throw new Error("Invalid or missing SDP");
          }

          logMessage("Received offer SDP:", data.data);

          try {
            await state.peerConnection.setRemoteDescription(
              new RTCSessionDescription({ sdp: data.data, type: "offer" })
            );
            logMessage("Successfully set remote description");
          } catch (err) {
            throw new Error(`Failed to set remote description: ${err.message}`);
          }

          // Apply queued ICE candidates
          state.iceCandidates.forEach(async (candidate) => {
            try {
              await state.peerConnection.addIceCandidate(
                new RTCIceCandidate(candidate)
              );
              logMessage("Added queued ICE candidate:", candidate.candidate);
            } catch (err) {
              console.error("Error adding queued ICE candidate:", err);
            }
          });
          state.iceCandidates = [];

          const answer = await state.peerConnection.createAnswer();
          await state.peerConnection.setLocalDescription(answer);
          logMessage("Created answer SDP:", answer.sdp);

          state.socket.emit(
            "message",
            JSON.stringify({
              type: "create_answer",
              uniqueID: data.callerId,
              name: state.user.name,
              data: { sdp: answer.sdp },
              callId: data.callId,
            })
          );

          state.currentCallId = data.callId;
          startCallBtn.disabled = true;
          endCallBtn.disabled = false;
          updateStatus(`Call started with ${data.name}`, "success");
          updateCallStatus("Active call");
        } catch (error) {
          console.error("Error handling offer:", error);
          showError(`Failed to handle call offer: ${error.message}`);
          endCall();
        }
      }

      // Handle answer received
      async function handleAnswerReceived(data) {
        try {
          if (!state.peerConnection) {
            console.error("No peer connection when answer received");
            return;
          }

          await state.peerConnection.setRemoteDescription(
            new RTCSessionDescription({ sdp: data.data, type: "answer" })
          );

          state.currentCallId = data.callId;
          updateStatus("Call connected", "success");
          updateCallStatus("Active call");
        } catch (error) {
          console.error("Error handling answer:", error);
          showError("Failed to handle call answer");
          endCall();
        }
      }

      // Handle ICE candidate
      async function handleIceCandidate(data) {
        try {
          const candidate = new RTCIceCandidate({
            sdpMLineIndex: data.data.sdpMLineIndex,
            sdpMid: data.data.sdpMid,
            candidate: data.data.sdpCandidate,
          });

          if (state.peerConnection && state.peerConnection.remoteDescription) {
            await state.peerConnection.addIceCandidate(candidate);
            logMessage("Added ICE candidate:", candidate.candidate);
          } else {
            state.iceCandidates.push(candidate);
            logMessage("Queued ICE candidate:", candidate.candidate);
          }
        } catch (error) {
          console.error("Error adding ICE candidate:", error);
          showError("Failed to add ICE candidate: " + error.message);
        }
      }

      // Handle call ended
      function handleCallEnded() {
        resetCall();
        updateStatus("Call ended", "success");
        updateCallStatus("No active call");
      }

      // Display chat message
      function displayMessage(data) {
        const time = data.timestamp
          ? new Date(data.timestamp).toLocaleTimeString()
          : new Date().toLocaleTimeString();
        const sender =
          data.senderId === state.user.id
            ? "You"
            : state.remoteUser.name || "Other";
        appendMessage(`[${time}] ${sender}: ${data.content}`);
      }

      // Connect user to signaling server
      async function connectUser() {
        try {
          state.user.id = document.getElementById("userId").value.trim();
          state.user.name = document.getElementById("userName").value.trim();
          state.user.gender = document.getElementById("userGender").value;

          if (!state.user.id || !state.user.name) {
            showError("Please enter a user ID and name");
            return;
          }

          if (!isValidId(state.user.id)) {
            showError(
              "User ID must be a valid format (24-character hex string)"
            );
            return;
          }

          await setupMedia();

          if (!state.socket) {
            initializeSocket();
          }

          state.socket.connect();

          state.socket.emit(
            "message",
            JSON.stringify({
              type: "store_user",
              uniqueID: state.user.id,
              name: state.user.name,
              gender: state.user.gender,
            })
          );

          state.user.connected = true;
          updateStatus("User registered, waiting for connection...", "success");
        } catch (error) {
          console.error("Error connecting user:", error);
          showError("Failed to connect user");
          resetConnection();
        }
      }

      // Start a call
      async function startCall() {
        try {
          if (!state.remoteUser.id) {
            showError("No remote user available");
            return;
          }

          if (!isValidId(state.remoteUser.id)) {
            showError("Invalid remote user ID");
            return;
          }

          createPeerConnection();
          const offer = await state.peerConnection.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true,
          });
          logMessage("Created offer SDP:", offer.sdp);

          await state.peerConnection.setLocalDescription(offer);

          state.socket.emit("message", {
            type: "create_offer",
            uniqueID: state.remoteUser.id,
            callerId: state.user.id,
            targetId: state.remoteUser.id,
            data: { sdp: offer.sdp }, // Ensure sdp is sent as a string
          });

          startCallBtn.disabled = true;
          endCallBtn.disabled = false;
          updateStatus("Call initiated...", "success");
          updateCallStatus("Calling...");
        } catch (error) {
          console.error("Error starting call:", error);
          showError("Failed to start call");
          endCall();
        }
      }

      // End the current call
      function endCall() {
        try {
          if (state.peerConnection) {
            state.peerConnection.close();
            state.peerConnection = null;
          }

          if (state.remoteUser.id) {
            state.socket.emit(
              "message",
              JSON.stringify({
                type: "end_call",
                uniqueID: state.remoteUser.id,
                name: state.user.name,
                gender: state.user.gender,
              })
            );
          }

          resetCall();
          updateStatus("Call ended", "success");
          updateCallStatus("No active call");
        } catch (error) {
          console.error("Error ending call:", error);
          showError("Failed to properly end call");
        }
      }

      // Send a chat message
      function sendMessage() {
        try {
          const content = messageInput.value.trim();
          if (!content || !state.remoteUser.id || !state.currentCallId) return;

          state.socket.emit(
            "message",
            JSON.stringify({
              type: "send_message",
              callId: state.currentCallId,
              content,
              senderId: state.user.id,
              receiverId: state.remoteUser.id,
            })
          );

          messageInput.value = "";
        } catch (error) {
          console.error("Error sending message:", error);
          showError("Failed to send message");
        }
      }

      // Set up media devices
      async function setupMedia() {
        try {
          state.localStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,
          });
          localVideo.srcObject = state.localStream;
        } catch (error) {
          console.error("Error accessing media devices:", error);
          showError("Could not access camera/microphone");
          throw error;
        }
      }

      // Create peer connection
      function createPeerConnection() {
        try {
          state.peerConnection = new RTCPeerConnection(configuration);

          state.localStream.getTracks().forEach((track) => {
            state.peerConnection.addTrack(track, state.localStream);
          });

          state.peerConnection.ontrack = (event) => {
            remoteVideo.srcObject = event.streams[0];
          };
          state.peerConnection.onicecandidate = (event) => {
            if (event.candidate && state.remoteUser.id) {
              state.socket.emit(
                "message",
                JSON.stringify({
                  type: "ice_candidate",
                  uniqueID: state.remoteUser.id,
                  name: state.user.name,
                  data: {
                    sdpMLineIndex: event.candidate.sdpMLineIndex,
                    sdpMid: event.candidate.sdpMid,
                    sdpCandidate: event.candidate.candidate,
                  },
                })
              );
              logMessage("Sent ICE candidate:", event.candidate.candidate);
            }
          };

          state.peerConnection.oniceconnectionstatechange = () => {
            const stateVal = state.peerConnection.iceConnectionState;
            logMessage("ICE connection state:", stateVal);
            if (stateVal === "failed") {
              console.error("ICE connection failed");
              state.peerConnection.restartIce(); // Attempt to recover
              showError("ICE connection failed, attempting to recover...");
            }
          };

          state.peerConnection.onconnectionstatechange = () => {
            const connState = state.peerConnection.connectionState;
            logMessage("Connection state:", connState);
            if (connState === "disconnected") {
              console.log("Peer connection disconnected");
              endCall();
            }
          };

          // Prefer specific codecs
          state.peerConnection.getTransceivers().forEach((transceiver) => {
            if (transceiver.sender.track.kind === "video") {
              const codecs = RTCRtpSender.getCapabilities("video").codecs;
              const preferredCodecs = codecs.filter(
                (codec) =>
                  codec.mimeType.includes("VP8") ||
                  codec.mimeType.includes("H264")
              );
              transceiver.setCodecPreferences(preferredCodecs);
            }
            if (transceiver.sender.track.kind === "audio") {
              const codecs = RTCRtpSender.getCapabilities("audio").codecs;
              const preferredCodecs = codecs.filter((codec) =>
                codec.mimeType.includes("opus")
              );
              transceiver.setCodecPreferences(preferredCodecs);
            }
          });
        } catch (error) {
          console.error("Error creating peer connection:", error);
          throw error;
        }
      }

      // Helper Functions
      function isValidId(id) {
        return /^[0-9a-fA-F]{24}$/.test(id);
      }

      function appendMessage(message) {
        const div = document.createElement("div");
        div.textContent = message;
        messagesDiv.appendChild(div);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
      }

      function updateStatus(message, type = "") {
        connectionStatus.textContent = message;
        connectionStatus.className = "status " + type;
      }

      function updateCallStatus(message, type = "") {
        callStatus.textContent = message;
        callStatus.className = "status " + type;
      }

      function showError(message) {
        console.error(message);
        const errorDiv = document.createElement("div");
        errorDiv.textContent = `Error: ${message}`;
        errorDiv.className = "error";
        messagesDiv.appendChild(errorDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
      }

      function logMessage(prefix, data) {
        console.log(prefix, data);
        if (typeof data !== "string") {
          data = JSON.stringify(data, null, 2);
        }
        appendMessage(`${prefix} ${data}`);
      }

      function resetCall() {
        if (state.peerConnection) {
          state.peerConnection.close();
          state.peerConnection = null;
        }
        remoteVideo.srcObject = null;
        startCallBtn.disabled = !state.remoteUser.id;
        endCallBtn.disabled = true;
        messageInput.disabled = true;
        sendMessageBtn.disabled = true;
        state.currentCallId = null;
        state.iceCandidates = [];
      }

      function resetConnection() {
        resetCall();
        if (state.localStream) {
          state.localStream.getTracks().forEach((track) => track.stop());
          state.localStream = null;
          localVideo.srcObject = null;
        }
        if (state.socket) {
          state.socket.disconnect();
        }
        state.user.connected = false;
        state.remoteUser = { id: "", name: "", gender: "" };
        startCallBtn.disabled = true;
        updateStatus("Not connected");
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", () => {
        messageInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter") sendMessage();
        });
      });
    </script>
  </body>
</html>
